# Plot only one variable
plot(watersheds["area_ha"],  key.pos = 1, breaks = "jenks")
# Plot geometry (geom) only
plot(st_geometry(watersheds))
plot(watersheds["name"], col = sf.colors(3, categorical = TRUE), border = 'grey',  axes = TRUE)
plot(watersheds["name"], col = sf.colors(5, categorical = TRUE), border = 'grey',  axes = TRUE)
plot(watersheds["name"], col = sf.colors(10, categorical = TRUE), border = 'grey',  axes = TRUE)
# Plot only one variable
plot(watersheds["area_ha"],  key.pos = 1)
query1 <- "SELECT * FROM ward_wgs84"
query1 <- "SELECT * FROM ward_wgs84"
# create df
wards <- st_read(con_pg, query=query1)
# Check structure
str(wards)
crs(wards)
# Look at first 6 rows
head(wate)
# Look at first 6 rows
head(wards)
# Plot geometry (geom) only
plot(st_geometry(wards))
# Check structure
str(wards)
crs(wards)
# Look at first 6 rows
head(wards)
# Check structure
str(wards)
# Plot only one variable
plot(watersheds["area_l_cd"],  key.pos = 1)
# Plot only one variable
plot(wards["area_l_cd"],  key.pos = 1)
# select only one record
SWHudsonBay <- watersheds[wards$"area_name"=="Etobicoke-Lakeshore", ]
# select only one record
EtoLake<- watersheds[wards$"area_name"=="Etobicoke-Lakeshore", ]
plot(st_geometry(EtoLake))
getwd()
st_write(EtoLake, "C:/Users/Peter R/Documents/data/shp/Etobicoke-Lakeshore.shp")
query1 <- "SELECT * FROM ward_wgs84"
# create df
wards <- st_read(con_pg, query=query1)
# Check structure of df
str(wards)
crs(wards)
# Look at first 6 rows
head(wards)
# Plot geometry (geom) only
plot(st_geometry(wards))
# Plot only one variable
plot(wards["area_l_cd"],  key.pos = 1)
# select only one record
EtoLake<- wards[wards$"area_name"=="Etobicoke-Lakeshore", ]
plot(st_geometry(EtoLake))
# Write to shp
st_write(EtoLake, "C:/Users/Peter R/Documents/data/shp/Etobicoke-Lakeshore.shp")
# Write to shp
st_write(EtoLake, "C:/Users/Peter R/Documents/data/shp/Etobicoke-Lakeshore.shp", overwrite=TRUE)
# Write to shp
st_write(EtoLake, "C:/Users/Peter R/Documents/data/shp/Etobicoke-Lakeshore.shp", append=FALSE)
# write to db
st_write(EtoLake, "PG:dbname=resnet1", layer_options = "OVERWRITE=true")
library(sf)
#install.packages("DBI")
library(DBI)
con_pg <- DBI::dbConnect(
drv = RPostgres::Postgres(),
host = "localhost",
port = 5432,
dbname = "resnet1",
user = Sys.getenv("username"),
password = Sys.getenv("pwd")
)
query1 <- "SELECT * FROM ward_wgs84"
# create df
wards <- st_read(con_pg, query=query1)
# Check structure of df
str(wards)
crs(wards)
# Look at first 6 rows
head(wards)
# Plot geometry (geom) only
plot(st_geometry(wards))
# Plot only one variable
plot(wards["area_l_cd"],  key.pos = 1)
# select only one record
EtoLake<- wards[wards$"area_name"=="Etobicoke-Lakeshore", ]
plot(st_geometry(EtoLake))
# write to db
st_write(EtoLake, "PG:dbname=resnet1", layer_options = "OVERWRITE=true")
# write to db
st_write(EtoLake, con_pg, layer_options = "OVERWRITE=true")
# write to db
st_write(EtoLake, con_pg, "etolake", layer_options = "OVERWRITE=true")
# write to db
st_write(EtoLake, con_pg, "etolake", layer_options = "OVERWRITE=true")
rTs2 <- readRDS("C:/Users/Peter R/Documents/st_trends_for_c/algonquin/output_h5p/NDVI_250m/rTs2.rds")
#=================================
# Load libraries
# ================================
# install.packages(c("strucchangeRcpp", "bfast"))
#library(terra)
#library(sf)
library(bfast)
library(rlang)
library(bfast)
detach("package:rlang", unload=TRUE)
#=================================
# Load libraries
# ================================
# install.packages(c("strucchangeRcpp", "bfast"))
#library(terra)
#library(sf)
library(bfast)
detach("package:strucchangeRcpp", unload = TRUE)
detach("package:zoo", unload = TRUE)
detach("package:sandwich", unload = TRUE)
#=================================
# Load libraries
# ================================
# install.packages(c("strucchangeRcpp", "bfast"))
#library(terra)
#library(sf)
library(bfast)
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
#=================================
# Load libraries
# ================================
# install.packages(c("strucchangeRcpp", "bfast"))
#library(terra)
#library(sf)
library(bfast)
library(bfast)
detach("package:strucchangeRcpp", unload = TRUE)
detach("package:sandwich", unload = TRUE)
detach("package:zoo", unload = TRUE)
library(rlang)
install.packages("rlang")
install.packages("rlang")
library(rlang)
install.packages("rlang")
library(rlang)
library(terra)
setwd("C:/Users/Peter R/github/mcsc")
r4 <- rast("~/projects/def-mfortin/georod/data/cec/NA_NALCMS_landcover_2015v2_30m/data/NA_NALCMS_landcover_2015v2_30m.tif")
library(terra)
#local test raster, Ontario only
#r4 <- terra::rast("C:/Users/Peter R/Documents/data/gis/cec/NA_NALCMS_2015_LC_30m_LAEA_mmu5pix_.tif")
# Compete raster for North America
#r4 <- rast("~/projects/def-mfortin/georod/data/cec/NA_NALCMS_2015_LC_30m_LAEA_mmu5pix_.tif")
# This is the new version of CEC
r4 <- rast("~/projects/def-mfortin/georod/data/cec/NA_NALCMS_landcover_2015v2_30m/data/NA_NALCMS_landcover_2015v2_30m.tif")
r4 <- rast("C:/Users/Peter R/Documents/data/gis/cec/Land_cover_2015v2_30m_TIF/NA_NALCMS_landcover_2015v2_30m/data/NA_NALCMS_landcover_2015v2_30m.tif")
r4
city <- city[!is.na(city$osm_id),]
city$pg_city <- gsub(" ", "_", city$osm_city)
city <- city[c(1:4, 6:30,32:35) ,6] # cec2 added
city <- read.csv("./misc/mcsc_city_list1.csv")
city <- city[!is.na(city$osm_id),]
city$pg_city <- gsub(" ", "_", city$osm_city)
#city <- city[(city$pg_city %in% c('Peterborough')),6]
#city <- city[(city$pg_city %in% c('Toronto')), 6]
#city <- city[1:4 ,6] #Skip Freiburg
#city <- city[6:10 ,6]
city <- city[c(1:4, 6:30,32:35) ,6]
city
pri <- priority_table %>% dplyr::select(feature, priority)
colnames(pri)<- c('mcsc', 'mcsc_value')
#cec <- read.csv('cec_north_america.csv')
rec_cec <- left_join(cec, pri, by='mcsc')
rec_cec_final <- rec_cec %>% mutate(mcsc_value = ifelse(mcsc == 'developed_na', 28, mcsc_value)) # This is not really needed as pri obj already has 28
#write.csv(rec_cec_final, 'reclass_cec_2_mcsc.csv')
#rec_cec_final <- read.csv('reclass_cec_2_mcsc.csv')
cecRes <- rec_cec_final
###reclassification table for copernicus
#cop <- read.csv('copernicus_reclassification_table.csv') %>% dplyr::select (copernicus, value, mcsc)
rec_cop <- left_join(cop, pri, by='mcsc')
#rec_cop %>% filter(is.na(mcsc_value.y)) #PR: ask Tiziana if x or y. Is seems not to matter
#rec_cop$mcsc[6]<-'linear_feature_na_traffic'
rec_cop$mcsc[7]<-'linear_feature_na_traffic'
rec_cop$mcsc[23]<-'linear_feature_vh_traffic'
rec_cop$mcsc[9]<-'linear_feature_rail'
rec_cop <- rec_cop %>% dplyr::select(1,2,3)
rec_cop <- left_join(rec_cop, pri, by='mcsc')
rec_cop_final <- rec_cop %>% mutate(mcsc_value= ifelse(mcsc == 'developed_na', 28, mcsc_value))
library(terra)
#install.packages("sqldf")
library(sqldf)
library(dplyr)
#sessionInfo()
library(DBI)
city <- read.csv("./misc/mcsc_city_list1.csv")
# table with the priority, resistance and source strength
priority_table <- read.csv('./misc/priority_table_v2.csv')
#resTab <- read.csv("./misc/priority_table_v2.csv")
#tables with the classes included in the Global landcover and their equivalence to our OSM-derived landcover classes
cec <- read.csv('./misc/cec_north_america.csv')
cop <- read.csv('./misc/copernicus_reclassification_table.csv')
#=====================================
# Fill in gaps with Land cover raster
#=====================================
# Perhaps it is best to run this code separately so that the lcover raster is only run once.
#local test raster, Ontario only
#r4 <- terra::rast("C:/Users/Peter R/Documents/data/gis/cec/NA_NALCMS_2015_LC_30m_LAEA_mmu5pix_.tif")
# Compete raster for North America
#r4 <- rast("~/projects/def-mfortin/georod/data/cec/NA_NALCMS_2015_LC_30m_LAEA_mmu5pix_.tif")
# This is the new version of CEC
r4 <- rast("~/projects/def-mfortin/georod/data/cec/NA_NALCMS_landcover_2015v2_30m/data/NA_NALCMS_landcover_2015v2_30m.tif")
#r4 <- rast("C:/Users/Peter R/Documents/data/gis/cec/Land_cover_2015v2_30m_TIF/NA_NALCMS_landcover_2015v2_30m/data/NA_NALCMS_landcover_2015v2_30m.tif")
#cecRes <- read.csv("./misc/cec_north_america_resistance_values.csv")
#priority_table <- read.csv("./misc/resistance_table.csv")
city <- city[!is.na(city$osm_id),]
city$pg_city <- gsub(" ", "_", city$osm_city)
#city <- city[(city$pg_city %in% c('Peterborough')),6]
#city <- city[(city$pg_city %in% c('Toronto')), 6]
#city <- city[1:4 ,6] #Skip Freiburg
#city <- city[6:10 ,6]
city <- city[c(1:4, 6:30,32:35) ,6] # cec2 added
#=================================
# Connect to PG db - STEP 2
#=================================
# add username and pwd to .Renviron
# PR's local database
# con_pg <- DBI::dbConnect(
# drv = RPostgres::Postgres(),
# host = "localhost",
# port = 5432,
# dbname = "osm",
# user = Sys.getenv("username"),
# password = Sys.getenv("pwd")
# )
# Remote server. Thsi assumes this R script is running within the server
con_pg <- DBI::dbConnect(
drv = RPostgres::Postgres(),
host = "cedar-pgsql-vm",
port = 5432,
dbname = "georod_db_osm"
)
#-------------------------------
# Modify CSVs
#-------------------------------
###reclassification table for CEC
pri <- priority_table %>% dplyr::select(feature, priority)
colnames(pri)<- c('mcsc', 'mcsc_value')
#cec <- read.csv('cec_north_america.csv')
rec_cec <- left_join(cec, pri, by='mcsc')
rec_cec_final <- rec_cec %>% mutate(mcsc_value = ifelse(mcsc == 'developed_na', 28, mcsc_value)) # This is not really needed as pri obj already has 28
#write.csv(rec_cec_final, 'reclass_cec_2_mcsc.csv')
#rec_cec_final <- read.csv('reclass_cec_2_mcsc.csv')
cecRes <- rec_cec_final
###reclassification table for copernicus
#cop <- read.csv('copernicus_reclassification_table.csv') %>% dplyr::select (copernicus, value, mcsc)
rec_cop <- left_join(cop, pri, by='mcsc')
#rec_cop %>% filter(is.na(mcsc_value.y)) #PR: ask Tiziana if x or y. Is seems not to matter
#rec_cop$mcsc[6]<-'linear_feature_na_traffic'
rec_cop$mcsc[7]<-'linear_feature_na_traffic'
rec_cop$mcsc[23]<-'linear_feature_vh_traffic'
rec_cop$mcsc[9]<-'linear_feature_rail'
rec_cop <- rec_cop %>% dplyr::select(1,2,3)
rec_cop <- left_join(rec_cop, pri, by='mcsc')
rec_cop_final <- rec_cop %>% mutate(mcsc_value= ifelse(mcsc == 'developed_na', 28, mcsc_value))
city
as.matrix(cecRes[,c(2,4)])
cecRes
k <- 1
queryEnv <- paste0("SELECT * FROM ",city[k],"_env", ";")
vectorEnv <- terra::vect(sf::st_read(con_pg, query=queryEnv))
con_pg <- DBI::dbConnect(
drv = RPostgres::Postgres(),
host = "localhost",
port = 5432,
dbname = "osm",
user = Sys.getenv("username"),
password = Sys.getenv("pwd")
)
queryEnv <- paste0("SELECT * FROM ",city[k],"_env", ";")
vectorEnv <- terra::vect(sf::st_read(con_pg, query=queryEnv))
# disconnect from db
dbDisconnect(con_pg)
con_pg <- DBI::dbConnect(
drv = RPostgres::Postgres(),
host = "localhost",
port = 5432,
dbname = "osm_ont",
user = Sys.getenv("username"),
password = Sys.getenv("pwd")
)
queryEnv <- paste0("SELECT * FROM ",city[k],"_env", ";")
vectorEnv <- terra::vect(sf::st_read(con_pg, query=queryEnv))
ext1 <- terra::buffer(vectorEnv, width=500)
# Get crs of N. America raster
newcrs <- terra::crs(r4, proj=TRUE)
# Project to North America raster projection
ext1Pj <- terra::project(ext1, newcrs)
# Crop NA land cover to city envelope extent
r5 <- terra::crop(r4, ext1Pj)
r5
outF <- "C:/Users/Peter R/Documents/PhD/tiziana/mcsc_proj/mammals/lcrasters"
r3 <- terra::rast(paste0(outF,"lcrasters/",city[k],"/output/",'osm_lcover.tif'))
paste0(outF,"lcrasters/",city[k],"/output/",'osm_lcover.tif')
outF <- "C:/Users/Peter R/Documents/PhD/tiziana/mcsc_proj/mammals/"
r3 <- terra::rast(paste0(outF,"lcrasters/",city[k],"/output/",'osm_lcover.tif'))
r3
r6 <- terra::project(r5, r3, method="near", align=TRUE)
r6
r5
r6 <- terra::crop(r6, r3)
r6
plot(r6, type="classes")
plot(r3, type="classes")
r7 <- terra::mask(r6, r3, inverse=TRUE, maskvalue=NA)
plot(r7, type="classes")
rclM <- as.matrix(cecRes[,c(2,4)])
#rclM <- matrix(rclM, ncol=2, byrow=TRUE)
r8 <- terra::classify(r7, rclM)
plot(r8, type="classes") # reclass CEC
r9 <- terra::cover(r3, r8)
plot(r9, type="classes") # cover
osmv7 <- terra::rast(paste0(outF,"lcrasters/",city[k],"/output/",'osm_lcover_v7.tif'))
osmv7 <- terra::rast(paste0(outF,"lcrasters/",city[k],"/output/",'osm_lcoverv7.tif'))
paste0(outF,"lcrasters/",city[k],"/output/",'osm_lcoverv7.tif')
osmv7 <- terra::rast(paste0(outF,"lcrasters/",city[k],"/output/",'all_lcover_v7.tif'))
osmv7
plot(osmv7, type="classes") # cover
rclMlargeMam <- as.matrix(priority_table[,c("priority", "res_LM")])
rclMlargeMam
rclMsmallMam <- as.matrix(priority_table[,c("priority", "res_SM")])
rclMsmallMam
rclMsourceStr <- as.matrix(priority_table[,c("priority", "source_strength")])
rclMsourceStr
city <- read.csv("./misc/mcsc_city_list1.csv")
city
dim(dfTest)
dim(df2)
outf5 <- "C:/Users/Peter R/Documents/st_trends_for_c/algonquin/ver2/data/"
library(terra)
library(sf)
library(foreach)
library(doParallel)
library(dplyr)
library(sqldf)
df2 <- readRDS( paste0(outf5,"df2_analytic_df_v3.rds"))
head(df2)
dfTest <- df2[!is.na(df2$elev),]
dfAllBrks <- sqldf(
"SELECT pix, year, CASE WHEN brkcom=1 THEN 0 ELSE 1 END AS brk, magnitude,
CASE WHEN fire_year > 0 THEN 1 ELSE null END fire,
CASE WHEN harv_year > 0  THEN 1 ELSE null END harv,
CASE WHEN insc_year >  0 THEN 1 ELSE null END insc,
for_age, for_dec, for_con, for_pro, elev, map, mat, map_lag1, mat_lag1,
map_lag2, mat_lag2, map_lag3, mat_lag3
FROM dfTest where magnitude is not null "
)
df2$brkcom <- ifelse(is.na(df2$brk), df2$no_brk, df2$brk)
dim(df2[which(df2$brkcom>=0 & df2$year==2020),])
dim(df2[which(df2$brkcom>=0 & df2$year==2010),])
# estimate mean 3 year lag average precipitation and temperature
df2$mean_map_lag3 <- (df2$map_lag1 + df2$map_lag2 + df2$map_lag3)/3
df2$mean_mat_lag3 <- (df2$mat_lag1 + df2$mat_lag2 + df2$mat_lag3)/3
dfTest <- df2[!is.na(df2$elev),] #elev has the right forest pixel box so we can use it to filter out null pixels
#dfTest <- df2[!is.na(df2$elev),] #elev has the right forest pixel box so we can use it to filter out null pixels
dim(dfTest) # 5966050, 29; 6731975      29
head(dfTest)
dfTest[sample(which(is.na(dfTest$brkcom)==T), 10),] # a pixel will have brkcom=NA in all pix-time rows where there is a break
dfTest[sample(which(!is.na(dfTest$brkcom)==T), 10),] # a pixel will have brkcom=1 in all pix-time rows when there is a break
dfTest[dfTest$"pix"==2050,]
dfAllBrks <- sqldf(
"SELECT pix, year, CASE WHEN brkcom=1 THEN 0 ELSE 1 END AS brk, magnitude,
CASE WHEN fire_year > 0 THEN 1 ELSE null END fire,
CASE WHEN harv_year > 0  THEN 1 ELSE null END harv,
CASE WHEN insc_year >  0 THEN 1 ELSE null END insc,
for_age, for_dec, for_con, for_pro, elev, map, mat, map_lag1, mat_lag1,
map_lag2, mat_lag2, map_lag3, mat_lag3
FROM dfTest where magnitude is not null "
)
dim(dfAllBrks) #15904, 18;
str(dfAllBrks)
summary(dfAllBrks)
head(dfAllBrks)
dfAllBrks[dfAllBrks$pix==314548,]
saveRDS(dfAllBrks, paste0(outf5,"dfAllBrks_v2.rds"))
set.seed(7)
dfAllBrksSample1 <- (dfAllBrks[sample(nrow(dfAllBrks), nrow(dfAllBrks)*0.05),]) # 5%, 795
head(dfAllBrksSample1)
dim(dfAllBrksSample1)
outf7 <- "C:/Users/Peter R/github/forc_trends/models/xgboost/data/"
write.table(format(dfAllBrksSample1[, c(2, 4:20)], digits=3),
paste0(outf7, "forest_evi_breaks_sam2.csv"), row.names=F,
col.names =c("year", "magnitude","fire","harvest","insects" ,"age","deciduous","conifers","protected","elevation","precipitation","temperature","precipitation_lag1", "temperature_lag1", "precipitation_lag2", "temperature_lag2", "precipitation_lag3", "temperature_lag3",), sep=',', quote = F)
dim(dfAllBrksSample1)
write.table(format(dfAllBrksSample1[, c(2, 4:20)], digits=3),
paste0(outf7, "forest_evi_breaks_sam2.csv"), row.names=F,
col.names =c("year", "magnitude","fire","harvest","insects" ,"age","deciduous","conifers","protected","elevation","precipitation","temperature","precipitation_lag1", "temperature_lag1", "precipitation_lag2", "temperature_lag2", "precipitation_lag3", "temperature_lag3"), sep=',', quote = F)
city
r1 <- rast("C:/Users/Peter R/Documents/data/gis/glad/Hansen_GFC-2022-v1.10_lossyear_50N_080W.tif")
vect0 <-vect("C:/Users/Peter R/Documents/PhD/resnet/data/gis/misc/algonquin_envelope_500m_buff_v1.shp")
r1 <- crop(r1, project(vect0, r1))
plot(r1, type="classes)
")
plot(r1, type="classes")
r1 <-  terra::subst(r1, 0, NA)
plot(r1, type="classes")
r10
fpath10 <- "C:/Users/Peter R/Documents/st_trends_for_c/algonquin/output_h5p/EVI_250m/drac/rasters/EVI_negBrks_16d.tif"
r10 <- rast(fpath10)
#plot(r1, type="classes")
r1 <- r1+2000
plot(r1, type="classes")
2001:2022
r1Seg <- segregate(r1, classes=c(2001:2022), keep=FALSE, other=NA, round=FALSE, digits=0)
global(r1, fun="isNA")
global(r1, fun="notNA")
r1Agg <- aggregate(r1Seg, fact, sum, na.rm=TRUE)
fact <- round(dim(r1Seg)[1:2] / dim(r10)[1:2]) #NOTE: this is correct as long as the extents are equivalent (not same projection)
r1Agg <- aggregate(r1Seg, fact, sum, na.rm=TRUE)
r1AggPj <- project(r1Agg, r10,  method='near', threads=TRUE)
i
i <- 1
cells(r1AggPj[[i]])
r1Res <- resample(r1AggPj, r10, method='near')
terra::ext(r1Res) <- terra::ext(r10)
plot(r1Res, type="classes")
plot(r1Res[1], type="classes")
plot(r1Res[[1]], type="classes")
r1Res
r1Agg
r1
r1Seg
r1Agg
r1AggPj
r1Res
plot(r1Res[[1]])
cellsL <- foreach (i=1:nlyr(r1Res), .inorder=TRUE) %do%
adjacent(r1Res[[i]], cells=cells(r1Res[[i]]), directions="queen", pairs=FALSE, include=TRUE)
cellsL[[36]]
cellsL[[22]]
foreach (i=1:length(cellsL), .inorder=TRUE) %do%
{r1Res[[i]][unique(na.omit(as.vector(cellsL[[i]])))] <- 1}
r1Res
dfL1 <- foreach (i=1:nlyr(r1Res), .inorder=TRUE) %do% {
if (is.na(cells(r1Res[[i]])[1])) {cbind.data.frame("pix"=NA, "value"= NA, "year"= as.numeric(names(r1Res[[i]]))) } else
{
cbind.data.frame(setNames(as.data.frame(r1Res[[i]], row.names=NULL, optional=FALSE, xy=FALSE, cells=TRUE, na.rm=NA),c("pix", "value")), "year"= as.numeric(names(r1Res[[i]])) )
#df0$year <- names(r2Res[[i]])
}
}
head(dfL1[[1]])
df1Hansen <- do.call(rbind, dfL1)
#head(df1)
#df1Fire <- df1
summary(df1Hansen)
head(df1Fire)
head(df1Hansen)
tail(df1Hansen)
dim(df1Hansen)
saveRDS(df1Fire, paste0(outf5,"df1Hansen.rds"))
saveRDS(df1Hansen, paste0(outf5,"df1Hansen.rds"))
#df1Hansen <- readRDS(paste0(outf5,"df1Hansen.rds"))
dim(df1Hansen)
global(r1, fun="notNA")
global(r1, fun="isNA")
dim(allBrksLDf)
folder1 <- "EVI_250m"
allBrksLDf <- readRDS(paste0("C:/Users/Peter R/Documents/st_trends_for_c/algonquin/output_h5p/", folder1,"/drac/allBrksbF0Df.rds")) # check
#allBrksLDf <- do.call(rbind.data.frame, allBrksL)
# This obj has all the pixels in the study area
names(allBrksLDf) <- c("pix","brk", "obs", "iter","brkdate25", "brkdate","brkdate95", "brkb1",  "brkb2", "magnitude")
head(allBrksLDf)
head(allBrksLDf[which(allBrksLDf$brk==0),])
dim(allBrksLDf) # 499317     10
dim(allBrksLDf[which(allBrksLDf$brk==0),])
dim(allBrksLDf[which(allBrksLDf$brk==1),])
head(allBrksLDf[which(allBrksLDf$pix==116141),])
summary(allBrksLDf)
allBrksLDf <- (allBrksLDf[which(!is.na(allBrksLDf$brk)),]) # The df with all cells is way too big. Here I subset to extract only forest pixels.
dim(allBrksLDf)
class(df2)
df20 <- sqldf("SELECT t0.pix, t0.year, t1.brk, t1.brkdate25, t1.brkdate, t1.brkdate95, t1.magnitude, t11.brk as no_brk
FROM df1Hansen t0
JOIN allBrksLDf t1 ON t0.pix=t1.pix AND t0.year=round(t1.brkdate)
")
df20 <- sqldf("SELECT t0.pix, t0.year, t1.brk, t1.brkdate25, t1.brkdate, t1.brkdate95, t1.magnitude
FROM df1Hansen t0
JOIN allBrksLDf t1 ON t0.pix=t1.pix AND t0.year=round(t1.brkdate)
")
dim(df20)
head(df20)
df20 <- sqldf("SELECT t0.pix, t0.year, t1.brk, t1.brkdate25, t1.brkdate, t1.brkdate95, t1.magnitude
FROM df1Hansen t0
JOIN allBrksLDf t1 ON t0.pix=t1.pix
")
dim(df20)
head(df20)
df20 <- sqldf("SELECT t0.pix, t0.year, t1.brk, t1.brkdate25, t1.brkdate, t1.brkdate95, t1.magnitude
FROM df1Hansen t0
RIGHT JOIN allBrksLDf t1 ON t0.pix=t1.pix AND t0.year=round(t1.brkdate)
WHERE t0.pix is null
")
