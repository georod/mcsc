df1 <- df_unique_res[,c('feature', 'type', 'view', 'priority')]
#priority_table_red$priority <- as.numeric(priority_table_red$priority)
# remove duplicates
df1 <- df1[!duplicated(df1), ]
#add resistance values in the priority_Table
#df1 <- left_join(df1, priority_table_red, by='priority')
# PR: this seems to not be needed as we are dropping t2. columns further down.
#df1 <- sqldf("SELECT t1.*, t2.res_LM, t2.res_SM, t2.source_strength FROM df1 t1 LEFT JOIN priority_table_red t2 on t1.priority=t2.priority")
#dim(df1)
# large_mammals (Only need to create land cover with largeMam or smallMam but not both as they both have the same class values)
df1 <- df1[!is.na(df1$priority),]
print("priority part done")
#largeMam <- df1 %>% dplyr::select("feature", "type", "view", "priority") # We should call this largeMam obj something else to avoid confusion
largeMam <- df1[,c("feature", "type", "view", "priority")] # We should call this largeMam obj something else to avoid confusion
#head(largeMam)
largeMam$type <- ifelse(is.na(largeMam$type), 'NULL', largeMam$type)
featUrb <- unique(df1$view)
#head(featUrb)
# To save list of features of each city
#dir.create(paste0(outF, "/", city[k],"/","misc"))
#saveRDS(df1, paste0(outF, "/", city[k],"/","misc", "/","df1"))
#detach("package:dplyr", unload=TRUE)
print("features part done")
# end.time <- Sys.time()
# time.taken <- end.time - start.time
# time.taken
# ------------------------------------------------------------
# Query individual layers in PG OSM database to create rasters
for (i in 1:length(featUrb)) {
vals <- sqldf::sqldf(paste0("SELECT distinct priority FROM largeMam WHERE view='", featUrb[i],"' ORDER BY priority;"))
for (j in 1:nrow(vals)) {
sqlPrimer <- sqldf::sqldf(paste0("SELECT distinct feature, type, priority, view FROM largeMam WHERE view='", featUrb[i],"' AND priority=", vals$priority[j], " ;"))
queryEnv <- paste0("SELECT * FROM ",city[k],"_env", ";")
# the [1] could be removed if there are no dups
#      queryUrFts <- paste0("SELECT ", sqlPrimer$priority[1]," as class, geom
# FROM
#  (",
#
#                          paste0("SELECT * FROM ", dfSf ,"WHERE view=","'" ,sqlPrimer$view[1], "'", " ", ifelse(grepl('NULL', paste(sqlPrimer$type, collapse = "', '")), paste0(" AND type IS NULL OR type ", paste0("IN (","'",paste(sqlPrimer$type, collapse = "', '"), "'", ")" )), paste0("AND TYPE IN (","'",paste(sqlPrimer$type, collapse = "', '"), "'", ")" ) )) ,
#
#
#                          ") t1 ")
dfSf$type <- ifelse(is.na(dfSf$type), 'NULL', dfSf$type)
vectorUrFts <- dfSf[which(dfSf$view==sqlPrimer$view[1] & dfSf$type %in% sqlPrimer$type),]
vectorUrFts$class <- sqlPrimer$priority[1]
#vectorEnv <- terra::vect(sf::st_read(con_pg, query=queryEnv))
raster1 <- terra::rast(vectorEnv, resolution=30, crs="EPSG:3857")
print(paste("done feature", featUrb[i]))
#queryUrFts <- paste0("SELECT * FROM ", city[i],"_ur_fts", ";" )
#vectorUrFts <- try(terra::vect(sf::st_read(con_pg, query=queryUrFts)) ) # when vector has no rows then Warning: 1: [SpatVector from sf] empty SpatVector
#if(class(vectorUrFts) == "try-error") { vectorUrFts <- c() }
if(length(vectorUrFts)==0)
{ print("empty vector")} else
{
rasterRes1 <- terra::rasterize(vectorUrFts, raster1, field="class", background=NA, touches=FALSE,
update=FALSE, cover=FALSE, overwrite=FALSE)
dir.create(paste0(outF,"lcrasters"))
dir.create(paste0(outF,"lcrasters/",city[k]))
terra::writeRaster(rasterRes1, paste0(outF,"lcrasters/",city[k],"/",sqlPrimer$view[1],"__",sqlPrimer$priority[1],"__",sqlPrimer$priority[1],".tif"), overwrite=TRUE)
}
}
}
}
for (j in 1:nrow(city)) {
dbSendQuery(con_pg, paste0("DROP TABLE IF EXISTS ", city$pg_city[j],"_env", " CASCADE;"))
#dbSendQuery(con_pg, paste0("CREATE TABLE ", city$pg_city[j],"_env", "  AS SELECT (row_number() OVER ())::int AS sid, relation_id::varchar(20), 'background'::varchar(30) AS feature, tags->>'name'::varchar(30)  AS type, tags ->> 'admin_level'::varchar(30) AS material, '' AS size, st_envelope(st_buffer(st_envelope(st_multi(st_buildarea(geom))), 500))::geometry(Polygon, 3857) AS geom  FROM boundaries WHERE tags->> 'boundary' IN ('administrative') AND tags->> 'name'=","'", city$osm_city[j],"'" , " AND tags ->> 'admin_level'=","'",city$admin_level[j], "';"))
dbSendQuery(con_pg, paste0("CREATE TABLE ", city$pg_city[j],"_env", "  AS SELECT (row_number() OVER ())::int AS sid, relation_id::varchar(20), 'background'::varchar(30) AS feature, tags->>'name'::varchar(30)  AS type, tags ->> 'admin_level'::varchar(30) AS material, '' AS size, st_envelope(st_buffer(st_envelope(st_multi(st_buildarea(geom))),", city$buffer[j]*1000, "))::geometry(Polygon, 3857) AS geom  FROM boundaries WHERE relation_id=", city$osm_id[j], " ;"))
dbSendQuery(con_pg, paste0("ALTER TABLE ", city$pg_city[j],"_env", " ADD CONSTRAINT ", city$pg_city[j],"_env", "_pkey PRIMARY KEY (sid);"))
dbSendQuery(con_pg, paste0("CREATE INDEX ", city$pg_city[j],"_env", "_geom_idx ON ", city$pg_city[j],"_env",  " USING gist (geom) WITH (FILLFACTOR=100) TABLESPACE pg_default;") )
print(city$pg_city[j])
}
city
nrow(city)
city <- read.csv("./misc/mcsc_city_list1.csv")
city <- city[!is.na(city$osm_id),]
city$pg_city <- gsub(" ", "_", city$osm_city)
#city <- city[!(city$pg_city %in% c('Toronto', 'Chicago', 'City_of_New_York', 'Fort_Collins')),]
#city <- city[(city$pg_city %in% c('Peterborough')),]
city <- city[(city$pg_city %in% c('Toronto')),]
print(city)
for (j in 1:nrow(city)) {
dbSendQuery(con_pg, paste0("DROP TABLE IF EXISTS ", city$pg_city[j],"_env", " CASCADE;"))
#dbSendQuery(con_pg, paste0("CREATE TABLE ", city$pg_city[j],"_env", "  AS SELECT (row_number() OVER ())::int AS sid, relation_id::varchar(20), 'background'::varchar(30) AS feature, tags->>'name'::varchar(30)  AS type, tags ->> 'admin_level'::varchar(30) AS material, '' AS size, st_envelope(st_buffer(st_envelope(st_multi(st_buildarea(geom))), 500))::geometry(Polygon, 3857) AS geom  FROM boundaries WHERE tags->> 'boundary' IN ('administrative') AND tags->> 'name'=","'", city$osm_city[j],"'" , " AND tags ->> 'admin_level'=","'",city$admin_level[j], "';"))
dbSendQuery(con_pg, paste0("CREATE TABLE ", city$pg_city[j],"_env", "  AS SELECT (row_number() OVER ())::int AS sid, relation_id::varchar(20), 'background'::varchar(30) AS feature, tags->>'name'::varchar(30)  AS type, tags ->> 'admin_level'::varchar(30) AS material, '' AS size, st_envelope(st_buffer(st_envelope(st_multi(st_buildarea(geom))),", city$buffer[j]*1000, "))::geometry(Polygon, 3857) AS geom  FROM boundaries WHERE relation_id=", city$osm_id[j], " ;"))
dbSendQuery(con_pg, paste0("ALTER TABLE ", city$pg_city[j],"_env", " ADD CONSTRAINT ", city$pg_city[j],"_env", "_pkey PRIMARY KEY (sid);"))
dbSendQuery(con_pg, paste0("CREATE INDEX ", city$pg_city[j],"_env", "_geom_idx ON ", city$pg_city[j],"_env",  " USING gist (geom) WITH (FILLFACTOR=100) TABLESPACE pg_default;") )
print(city$pg_city[j])
}
city <- read.csv("./misc/mcsc_city_list1.csv")
city <- city[!is.na(city$osm_id),]
city$pg_city <- gsub(" ", "_", city$osm_city)
#city <- city[(city$pg_city %in% c('Peterborough')),6]
city <- city[(city$pg_city %in% c('Toronto')), 6]
city
for (k in 1:length(city)) {
#-----------------------------------
# Create city-specific urban features
#-----------------------------------
city0 <- paste0(city[k],"_env")
# Run features_union_string to get object pg_union_views0
#pg_union_views0 <- paste(readLines("./sql/features_union_string.txt"), collapse="\n")
#pg_union_views0 <- source("./R/features_union_string.R")
# df <- dbGetQuery(con_pg,  pg_union_views0)
# class(df)
# str(df)
dfSf <- terra::vect(sf::st_read(con_pg, query=pg_union_views0))
#str(dfSf)
df <- as.data.frame(dfSf, row.names=NULL, optional=FALSE, geom=NULL)
#print("union part done")
#----------------------------------
# Create city specific priority df
#----------------------------------
##create table with priority values
#df_unique2 <- df %>% dplyr::count(feature, type, material, size, view, .drop=FALSE)
df_unique <- sqldf("SELECT feature, type, material, size, view, count(*) as count FROM df GROUP BY feature, type, material, size, view")
##set priorities to avoid conflicting resistance values within the same priority level
##will we have trouble with waterways set as the same priority as water, maybe we can directly union them in PG as one single view
df_unique[which(grepl("homeowner's", df_unique$type, fixed=TRUE)),2] <- "homeowners_association" #PR: Do we need this? Yes.
df_unique_res <- sqldf("SELECT feature,
CASE
WHEN feature  =  'industrial' THEN 1
WHEN feature  =  'commercial' THEN 2
WHEN feature  =  'institutional' THEN 3
WHEN feature  =  'residential' THEN 4
WHEN feature  =  'landuse_rail' THEN 5
WHEN feature  =  'open_green_area' THEN 6
WHEN feature  =  'protected_area' THEN 7
WHEN feature  =  'resourceful_green_area' THEN 8
WHEN feature  =  'hetero_green_area' THEN 9
WHEN feature  =  'bare_soil' THEN 10
WHEN feature  =  'dense_green_area' THEN 11
WHEN feature  =  'water' THEN 12
WHEN feature  =  'waterways' THEN 12
WHEN feature  =  'parking_surface' THEN 13
WHEN feature  =  'building' THEN 14
WHEN feature  =  'linear_feature_vh_traffic' THEN  15
WHEN feature  =  'linear_feature_no_traffic_side' THEN  16
WHEN feature  =  'linear_feature_na_traffic' THEN   17
WHEN feature  =  'linear_feature_vl_traffic' THEN  18
WHEN feature  =  'linear_feature_l_traffic' THEN  19
WHEN feature  =  'linear_feature_m_traffic' THEN  20
WHEN feature  =  'linear_feature_h_traffic_ls' THEN  21
WHEN feature  =  'linear_feature_h_traffic_hs' THEN  22
WHEN feature  =  'linear_feature_rail_trams' THEN  23
WHEN feature  =  'linear_feature_no_traffic' THEN  24
WHEN feature  =  'linear_feature_rail' THEN  25
WHEN feature  =  'linear_feature_rail_abandoned' THEN  26
WHEN feature  =  'barrier'  THEN  27
END AS priority, type, material, size, view
FROM df_unique")
df_unique_res$class <- df_unique_res$priority
#View(df_unique_res)
#df_unique_res$priority <- as.numeric(df_unique_res$priority)
df1 <- df_unique_res[,c('feature', 'type', 'view', 'priority')]
#priority_table_red$priority <- as.numeric(priority_table_red$priority)
# remove duplicates
df1 <- df1[!duplicated(df1), ]
#add resistance values in the priority_Table
#df1 <- left_join(df1, priority_table_red, by='priority')
# PR: this seems to not be needed as we are dropping t2. columns further down.
#df1 <- sqldf("SELECT t1.*, t2.res_LM, t2.res_SM, t2.source_strength FROM df1 t1 LEFT JOIN priority_table_red t2 on t1.priority=t2.priority")
#dim(df1)
# large_mammals (Only need to create land cover with largeMam or smallMam but not both as they both have the same class values)
df1 <- df1[!is.na(df1$priority),]
print("priority part done")
#largeMam <- df1 %>% dplyr::select("feature", "type", "view", "priority") # We should call this largeMam obj something else to avoid confusion
largeMam <- df1[,c("feature", "type", "view", "priority")] # We should call this largeMam obj something else to avoid confusion
#head(largeMam)
largeMam$type <- ifelse(is.na(largeMam$type), 'NULL', largeMam$type)
featUrb <- unique(df1$view)
#head(featUrb)
# To save list of features of each city
#dir.create(paste0(outF, "/", city[k],"/","misc"))
#saveRDS(df1, paste0(outF, "/", city[k],"/","misc", "/","df1"))
#detach("package:dplyr", unload=TRUE)
print("features part done")
# end.time <- Sys.time()
# time.taken <- end.time - start.time
# time.taken
# ------------------------------------------------------------
# Query individual layers in PG OSM database to create rasters
for (i in 1:length(featUrb)) {
vals <- sqldf::sqldf(paste0("SELECT distinct priority FROM largeMam WHERE view='", featUrb[i],"' ORDER BY priority;"))
for (j in 1:nrow(vals)) {
sqlPrimer <- sqldf::sqldf(paste0("SELECT distinct feature, type, priority, view FROM largeMam WHERE view='", featUrb[i],"' AND priority=", vals$priority[j], " ;"))
queryEnv <- paste0("SELECT * FROM ",city[k],"_env", ";")
# the [1] could be removed if there are no dups
#      queryUrFts <- paste0("SELECT ", sqlPrimer$priority[1]," as class, geom
# FROM
#  (",
#
#                          paste0("SELECT * FROM ", dfSf ,"WHERE view=","'" ,sqlPrimer$view[1], "'", " ", ifelse(grepl('NULL', paste(sqlPrimer$type, collapse = "', '")), paste0(" AND type IS NULL OR type ", paste0("IN (","'",paste(sqlPrimer$type, collapse = "', '"), "'", ")" )), paste0("AND TYPE IN (","'",paste(sqlPrimer$type, collapse = "', '"), "'", ")" ) )) ,
#
#
#                          ") t1 ")
dfSf$type <- ifelse(is.na(dfSf$type), 'NULL', dfSf$type)
vectorUrFts <- dfSf[which(dfSf$view==sqlPrimer$view[1] & dfSf$type %in% sqlPrimer$type),]
vectorUrFts$class <- sqlPrimer$priority[1]
#vectorEnv <- terra::vect(sf::st_read(con_pg, query=queryEnv))
raster1 <- terra::rast(vectorEnv, resolution=30, crs="EPSG:3857")
print(paste("done feature", featUrb[i]))
#queryUrFts <- paste0("SELECT * FROM ", city[i],"_ur_fts", ";" )
#vectorUrFts <- try(terra::vect(sf::st_read(con_pg, query=queryUrFts)) ) # when vector has no rows then Warning: 1: [SpatVector from sf] empty SpatVector
#if(class(vectorUrFts) == "try-error") { vectorUrFts <- c() }
if(length(vectorUrFts)==0)
{ print("empty vector")} else
{
rasterRes1 <- terra::rasterize(vectorUrFts, raster1, field="class", background=NA, touches=FALSE,
update=FALSE, cover=FALSE, overwrite=FALSE)
dir.create(paste0(outF,"lcrasters"))
dir.create(paste0(outF,"lcrasters/",city[k]))
terra::writeRaster(rasterRes1, paste0(outF,"lcrasters/",city[k],"/",sqlPrimer$view[1],"__",sqlPrimer$priority[1],"__",sqlPrimer$priority[1],".tif"), overwrite=TRUE)
}
}
}
}
pg_union_views0
source("./R/features_union_string.R")
rm(pg_union_views0)
source("./R/features_union_string.R")
pg_union_views0
head(largeMam)
sam2 <- sample(10, terra::as.points(terra::rast(paste0(outF,"lcrasters/",city[k],"/output/",'all_lcover.tif')), values=TRUE, na.rm=TRUE, na.all=FALSE), replace=FALSE)
city <- "Peterborough"
city
sam2 <- sample(10, terra::as.points(terra::rast(paste0(outF,"lcrasters/",city[k],"/output/",'all_lcover.tif')), values=TRUE, na.rm=TRUE, na.all=FALSE), replace=FALSE)
sam0 <- terra::rast(paste0(outF,"lcrasters/",city[k],"/output/",'all_lcover.tif'))
sam0
sam1 <- terra::spatSample(sam0, 10, method="stratified", replace=FALSE, na.rm=FALSE,
as.raster=FALSE, as.df=TRUE, as.points=TRUE, values=TRUE, cells=TRUE,
xy=FALSE, ext=NULL, warn=TRUE, weights=NULL, exp=5)
table(sam1)
names(sam1)
names(sam1) <- c("cell", "value")
table(sam1$value)
terra::writeVector(sam1, paste0(outF,"lcrasters/",city[k],"/output/", city[k], "_sample2", ".geojson"), filetype="GeoJson", layer=NULL, insert=FALSE,
overwrite=TRUE, options="ENCODING=UTF-8")
head(sam1)
sam1Df <- as.data.frame(sam1[,c(1,2)])
dim(sam1Df)
head(largeMam)
priority_table
featureLabs
featureLabs0 <- unique(priority_table[,c(2,3)])
featureLabs0
dim(featureLabs)
dim(featureLabs0)
featureLabs <- unique(priority_table[,c(2,3)])
(unique(featureLabs[featureLabs$view!='water', ]))
(unique(featureLabs[featureLabs$feature!='water', ]))
featureLabs <- (unique(featureLabs[featureLabs$feature!='water', ])) # You need to get rid of water or waterways otherwise you get duplicates
sam1Df2 <- sqldf("SELECT t1.*, t2.view FROM sam1Df t1 JOIN featureLabs t2 ON t1.value=t2.priority")
sam1Df2 <- sqldf("SELECT t1.*, t2.feature FROM sam1Df t1 JOIN featureLabs t2 ON t1.value=t2.priority")
dim(sam1Df2)
dim(sam1Df)
featureLabs
priority_table
featureLabs
dim(sam1Df2)
unique(sam1Df2$value)
unique(sam1Df1$value)
unique(sam1Df$value)
length(unique(sam1Df$value))
featureLabs
unique(priority_table[,c(2,3)])
featureLabs <- unique(priority_table[,c(2,3)])
dim(featureLabs)
featureLabs <- (unique(featureLabs[featureLabs$feature!='waterways', ])) # You need to get rid of water or waterways otherwise you get duplicates
dim(featureLabs)
dim(sam1Df)
sam1Df2 <- sqldf("SELECT t1.*, t2.feature FROM sam1Df t1 JOIN featureLabs t2 ON t1.value=t2.priority")
dim(sam1Df2)
head(sam1Df2)
#dim(sam1Df2)
#head(sam1Df2)
sam1Df2$rowid <- 1:nrow(sam1Df2)
head(sam1Df2)
#write.csv(sam1Df2[order(sam1Df2$cell), c(4,1:3)], paste0(outF,"lcrasters/",city[k],"/output/", city[k], "_sample1_df", ".csv") , row.names = FALSE)
write.csv(sam1Df2[,c(4,1:3)], paste0(outF,"lcrasters/",city[k],"/output/", city[k], "_sample2_df", ".csv") , row.names = FALSE)
city
rclMlargeMam <- as.matrix(resTab[,c("class", "res_large_mammals")])
r10 <- classify(r9, rclMlargeMam)
writeRaster(r10, paste0(outF,"lcrasters/",city[k],"/output/",'largemam_res.tif'), overwrite=TRUE)
# Create small mammal raster
rclMsmallMam <- as.matrix(resTab[,c("class", "res_small_mammals")])
r11 <- classify(r9, rclMsmallMam)
writeRaster(r11, paste0(outF,"lcrasters/",city[k],"/output/",'smallmam_res.tif'), overwrite=TRUE)
# Create source strength
rclMsourceStr <- as.matrix(resTab[,c("class", "source_strength")])
r12 <- classify(r9, rclMsourceStr)
writeRaster(r12, paste0(outF,"lcrasters/",city[k],"/output/",'source_strength.tif'), overwrite=TRUE)
resTab
priority_table
priority_table
names(priority_table)
rclMlargeMam <- as.matrix(priority_table[,c("priority", "res_LM")])
r10 <- classify(r9, rclMlargeMam)
# Create large mammal raster
rclMlargeMam <- as.matrix(priority_table[,c("priority", "res_LM")])
r10 <- terra::classify(r9, rclMlargeMam)
terra::writeRaster(r10, paste0(outF,"lcrasters/",city[k],"/output/",'largemam_res.tif'), overwrite=TRUE)
# Create small mammal raster
rclMsmallMam <- as.matrix(priority_table[,c("priority", "res_SM")])
r11 <- terra::classify(r9, rclMsmallMam)
terra::writeRaster(r11, paste0(outF,"lcrasters/",city[k],"/output/",'smallmam_res.tif'), overwrite=TRUE)
# Create source strength
rclMsourceStr <- as.matrix(priority_table[,c("priority", "source_strength")])
r12 <- terra::classify(r9, rclMsourceStr)
terra::writeRaster(r12, paste0(outF,"lcrasters/",city[k],"/output/",'source_strength.tif'), overwrite=TRUE)
# list of cities with OSM ID
city <- read.csv("./misc/mcsc_city_list1.csv")
city <- city[!is.na(city$osm_id),]
city$pg_city <- gsub(" ", "_", city$osm_city)
city
city[(city$pg_city %in% c('Toronto')), 6]
city[,6]
#city <- city[(city$pg_city %in% c('Peterborough')),6]
city <- city[(city$pg_city %in% c('Toronto')), 6]
city
# list of cities with OSM ID
city <- read.csv("./misc/mcsc_city_list1.csv")
city <- city[!is.na(city$osm_id),]
city$pg_city <- gsub(" ", "_", city$osm_city)
city <- city[(city$pg_city %in% c('Peterborough')),6]
city
outF
# list of cities with OSM ID
city <- read.csv("./misc/mcsc_city_list1.csv")
# table with all the views we create with PG admin
#view_table <- read.csv('./misc/reference_all_views.csv', header=TRUE)
#view_table <- read.csv('./misc/reference_all_views.csv', header=TRUE)
# table with the priority, resistance and source strength
priority_table <- read.csv('./misc/priority_table_v2.csv')
#resTab <- read.csv("./misc/priority_table_v2.csv")
#tables with the classes included in the Global landcover and their equivalence to our OSM-derived landcover classes
cec <- read.csv('./misc/cec_north_america.csv')
cop <- read.csv('./misc/copernicus_reclassification_table.csv')
#=====================================
# Fill in gaps with Land cover raster
#=====================================
# Perhaps it is best to run this code separately so that the lcover raster is only run once.
#local test raster
#r4 <- terra::rast("C:/Users/Peter R/Documents/data/gis/cec/NA_NALCMS_2015_LC_30m_LAEA_mmu5pix_.tif")
r4 <- rast("~/projects/def-mfortin/georod/data/cec/NA_NALCMS_2015_LC_30m_LAEA_mmu5pix_.tif")
cecRes <- read.csv("./misc/cec_north_america_resistance_values.csv")
#priority_table <- read.csv("./misc/resistance_table.csv")
city <- city[!is.na(city$osm_id),]
city$pg_city <- gsub(" ", "_", city$osm_city)
city <- city[(city$pg_city %in% c('Peterborough')),6]
#city <- city[(city$pg_city %in% c('Toronto')), 6]
#city <- city[ ,6]
#-------------------------------
# Modify CSVs
#-------------------------------
###reclassification table for CEC
pri <- priority_table %>% dplyr::select(feature, priority)
colnames(pri)<- c('mcsc', 'mcsc_value')
#cec <- read.csv('cec_north_america.csv')
rec_cec <- left_join(cec, pri, by='mcsc')
rec_cec_final <- rec_cec %>% mutate(mcsc_value = ifelse(mcsc == 'developed_na', 28, mcsc_value))
#write.csv(rec_cec_final, 'reclass_cec_2_mcsc.csv')
#rec_cec_final <- read.csv('reclass_cec_2_mcsc.csv')
###reclassification table for copernicus
#cop <- read.csv('copernicus_reclassification_table.csv') %>% dplyr::select (copernicus, value, mcsc)
rec_cop <- left_join(cop, pri, by='mcsc')
rec_cop %>% filter(is.na(mcsc_value))
#rec_cop$mcsc[6]<-'linear_feature_na_traffic'
rec_cop$mcsc[7]<-'linear_feature_na_traffic'
rec_cop$mcsc[23]<-'linear_feature_vh_traffic'
rec_cop$mcsc[9]<-'linear_feature_rail'
rec_cop <- rec_cop %>% dplyr::select(1,2,3)
rec_cop <- left_join(rec_cop, pri, by='mcsc')
rec_cop_final <- rec_cop %>% mutate(mcsc_value= ifelse(mcsc == 'developed_na', 28, mcsc_value))
# write.csv(rec_cop_final, 'reclass_copernicus_2_mcsc.csv')
# rec_cop_final <- read.csv('reclass_copernicus_2_mcsc.csv')
cecRes <- rec_cec_final
#===============================
# files needed to run this
#================================
## might have to ad a path to subfolder data/
# list of cities with OSM ID
city <- read.csv("./misc/mcsc_city_list1.csv")
# table with all the views we create with PG admin
#view_table <- read.csv('./misc/reference_all_views.csv', header=TRUE)
#view_table <- read.csv('./misc/reference_all_views.csv', header=TRUE)
# table with the priority, resistance and source strength
priority_table <- read.csv('./misc/priority_table_v2.csv')
#resTab <- read.csv("./misc/priority_table_v2.csv")
#tables with the classes included in the Global landcover and their equivalence to our OSM-derived landcover classes
cec <- read.csv('./misc/cec_north_america.csv')
cop <- read.csv('./misc/copernicus_reclassification_table.csv')
#=====================================
# Fill in gaps with Land cover raster
#=====================================
# Perhaps it is best to run this code separately so that the lcover raster is only run once.
#local test raster
r4 <- terra::rast("C:/Users/Peter R/Documents/data/gis/cec/NA_NALCMS_2015_LC_30m_LAEA_mmu5pix_.tif")
#r4 <- rast("~/projects/def-mfortin/georod/data/cec/NA_NALCMS_2015_LC_30m_LAEA_mmu5pix_.tif")
cecRes <- read.csv("./misc/cec_north_america_resistance_values.csv")
#priority_table <- read.csv("./misc/resistance_table.csv")
city <- city[!is.na(city$osm_id),]
city$pg_city <- gsub(" ", "_", city$osm_city)
city <- city[(city$pg_city %in% c('Peterborough')),6]
#city <- city[(city$pg_city %in% c('Toronto')), 6]
#city <- city[ ,6]
#-------------------------------
# Modify CSVs
#-------------------------------
###reclassification table for CEC
pri <- priority_table %>% dplyr::select(feature, priority)
colnames(pri)<- c('mcsc', 'mcsc_value')
#cec <- read.csv('cec_north_america.csv')
rec_cec <- left_join(cec, pri, by='mcsc')
rec_cec_final <- rec_cec %>% mutate(mcsc_value = ifelse(mcsc == 'developed_na', 28, mcsc_value))
#write.csv(rec_cec_final, 'reclass_cec_2_mcsc.csv')
#rec_cec_final <- read.csv('reclass_cec_2_mcsc.csv')
###reclassification table for copernicus
#cop <- read.csv('copernicus_reclassification_table.csv') %>% dplyr::select (copernicus, value, mcsc)
rec_cop <- left_join(cop, pri, by='mcsc')
rec_cop %>% filter(is.na(mcsc_value))
#rec_cop$mcsc[6]<-'linear_feature_na_traffic'
rec_cop$mcsc[7]<-'linear_feature_na_traffic'
rec_cop$mcsc[23]<-'linear_feature_vh_traffic'
rec_cop$mcsc[9]<-'linear_feature_rail'
rec_cop <- rec_cop %>% dplyr::select(1,2,3)
rec_cop <- left_join(rec_cop, pri, by='mcsc')
rec_cop_final <- rec_cop %>% mutate(mcsc_value= ifelse(mcsc == 'developed_na', 28, mcsc_value))
# write.csv(rec_cop_final, 'reclass_copernicus_2_mcsc.csv')
# rec_cop_final <- read.csv('reclass_copernicus_2_mcsc.csv')
cecRes <- rec_cec_final
pri
cop
###reclassification table for copernicus
#cop <- read.csv('copernicus_reclassification_table.csv') %>% dplyr::select (copernicus, value, mcsc)
rec_cop <- left_join(cop, pri, by='mcsc')
rec_cop %>% filter(is.na(mcsc_value))
rec_cop %>% filter(is.na(rec_cop$mcsc_value))
rec_cop %>% filter(is.na(mcsc_value))
rec_cop
cop
pri
rec_cop %>% filter(is.na(mcsc_value.y)) #PR: ask Tiziana if x or y.
###reclassification table for copernicus
#cop <- read.csv('copernicus_reclassification_table.csv') %>% dplyr::select (copernicus, value, mcsc)
rec_cop <- left_join(cop, pri, by='mcsc')
rec_cop %>% filter(is.na(mcsc_value.x)) #PR: ask Tiziana if x or y.
###reclassification table for copernicus
#cop <- read.csv('copernicus_reclassification_table.csv') %>% dplyr::select (copernicus, value, mcsc)
rec_cop <- left_join(cop, pri, by='mcsc')
rec_cop %>% filter(is.na(mcsc_value.y)) #PR: ask Tiziana if x or y.
#rec_cop$mcsc[6]<-'linear_feature_na_traffic'
rec_cop$mcsc[7]<-'linear_feature_na_traffic'
rec_cop$mcsc[23]<-'linear_feature_vh_traffic'
rec_cop$mcsc[9]<-'linear_feature_rail'
rec_cop
rec_cop <- rec_cop %>% dplyr::select(1,2,3)
rec_cop <- left_join(rec_cop, pri, by='mcsc')
rec_cop_final <- rec_cop %>% mutate(mcsc_value= ifelse(mcsc == 'developed_na', 28, mcsc_value))
rec_cop_final
# write.csv(rec_cop_final, 'reclass_copernicus_2_mcsc.csv')
# rec_cop_final <- read.csv('reclass_copernicus_2_mcsc.csv')
cecRes <- rec_cec_final
city
for (k in 1:length(city)) {
queryEnv <- paste0("SELECT * FROM ",city[k],"_env", ";")
vectorEnv <- terra::vect(sf::st_read(con_pg, query=queryEnv))
# Get extent of city envelope
ext1 <- terra::buffer(vectorEnv, width=500)
# Get crs of N. America raster
newcrs <- terra::crs(r4, proj=TRUE)
# Project to North America raster projection
ext1Pj <- terra::project(ext1, newcrs)
# Crop NA land cover to city envelope extent
r5 <- terra::crop(r4, ext1Pj)
r3 <- terra::rast(paste0(outF,"lcrasters/",city[k],"/output/",'osm_lcover.tif'))
# transform cropped raster crs to EPSG 3857 , "EPSG:3857"
r6 <- terra::project(r5, r3, method="near", align=TRUE)
# crop to ensure rasters have the same extent
r6 <- terra::crop(r6, r3)
terra::writeRaster(r6, paste0(outF,"lcrasters/",city[k],"/output/",'cec_lcover.tif'), overwrite=TRUE)
#plot(r6, type="classes")
# Mask raster
r7 <- terra::mask(r6, r3, inverse=TRUE, maskvalue=NA)
rclM <- as.matrix(cecRes[,c(2,4)])
#rclM <- matrix(rclM, ncol=2, byrow=TRUE)
r8 <- terra::classify(r7, rclM)
#plot(r8, type="classes")
r9 <- terra::cover(r3, r8)
#r9 <- subst(r9, 0, 100)
#plot(r9, type="classes")
terra::writeRaster(r9, paste0(outF,"lcrasters/",city[k],"/output/",'all_lcover.tif'), overwrite=TRUE)
# Create large mammal raster
rclMlargeMam <- as.matrix(priority_table[,c("priority", "res_LM")])
r10 <- terra::classify(r9, rclMlargeMam)
terra::writeRaster(r10, paste0(outF,"lcrasters/",city[k],"/output/",'largemam_res.tif'), overwrite=TRUE)
# Create small mammal raster
rclMsmallMam <- as.matrix(priority_table[,c("priority", "res_SM")])
r11 <- terra::classify(r9, rclMsmallMam)
terra::writeRaster(r11, paste0(outF,"lcrasters/",city[k],"/output/",'smallmam_res.tif'), overwrite=TRUE)
# Create source strength
rclMsourceStr <- as.matrix(priority_table[,c("priority", "source_strength")])
r12 <- terra::classify(r9, rclMsourceStr)
terra::writeRaster(r12, paste0(outF,"lcrasters/",city[k],"/output/",'source_strength.tif'), overwrite=TRUE)
}
city <- read.csv("./misc/mcsc_city_list1.csv")
city <- city[!is.na(city$osm_id),]
city$pg_city <- gsub(" ", "_", city$osm_city)
city
rast("C:/Users/Peter%20R/Documents/PhD/tiziana/test5/tizianas_output/all_lcover.tif")
rTO <- rast("C:/Users/Peter%20R/Documents/PhD/tiziana/test5/tizianas_output/all_lcover.tif")
rTO
rTO
